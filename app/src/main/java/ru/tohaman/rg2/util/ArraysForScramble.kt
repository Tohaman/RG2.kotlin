package ru.tohaman.rg2.util

import ru.tohaman.rg2.R

/**
 * Created by Test on 25.12.2017.
 * Таблицы соответствий to необходимые для алгоритмов сборки кубика
 */

// Табличка цветов кубика 0-синий, 1-оранжевый и т.д.
val cubeColor = intArrayOf(
        R.color.c_b,
        R.color.c_o,
        R.color.c_w,
        R.color.c_r,
        R.color.c_y,
        R.color.c_g,
        R.color.c_bl)

val cubeColor4PLL = intArrayOf(
        R.color.c_r,
        R.color.c_g,
        R.color.c_o,
        R.color.c_b,
        R.color.c_r,
        R.color.c_g,
        R.color.c_o,
        R.color.c_b
)

//Создаем табличку (словарь) номеров основных ребер, для определенных сочетаний цветов, остальные элементы равны null
//первое число цвет, например 12 = синий 1 + оранжевый 2
//второе число номер основного(первого) цвета как элемента куба (0..53)
val mainEdge = hashMapOf(
        12 to 3,      //для сине-оранжевого ребра
        13 to 7,      //для сине-белого ребра
        14 to 5,      //для сине-красного ребра
        15 to 1,      //для сине-желтого ребра
        21 to 10,     //для оранжево-синей ребра
        23 to 14,     //для оранжево-белого ребра
        25 to 12,     //для оранжево-желтого ребра
        26 to 16,     //для оранжево-зеленого ребра
        31 to 19,     //для бело-синей ребра
        32 to 21,     //для бело-оранжевого ребра
        34 to 23,     //для бело-красного ребра
        36 to 25,     //для бело-зеленого ребра
        41 to 28,     //для красно-синей ребра
        43 to 30,     //для красно-белого ребра
        45 to 32,     //для красно-желтого ребра
        46 to 34,     //для красно-зеленого ребра
        51 to 37,     //для желто-синей ребра
        52 to 41,     //для желто-оранжевого ребра
        54 to 39,     //для желто-красного ребра
        56 to 43,     //для желто-зеленого ребра
        62 to 48,     //для зелено-оранжевого ребра
        63 to 46,     //для зелено-белого ребра
        64 to 50,     //для зелено-красного ребра
        65 to 52)     //для зелено-желтого ребра

//Создаем табличку соответствия основного цвета и дополнительного цвета ребра [где искать второй цвет)
//первая и вторая цифра номер соответствующих друг другу позиций ребра в кубе. т.е. 1->37, 37->1
val dopEdge = hashMapOf(
        1 to 37,           //сине-желтое
        3 to 10,           //сине-оранжевое
        5 to 28,           //сине-красное
        7 to 19,           //сине-белое
        10 to 3,           //оранжево-синяя
        12 to 41,          //оранжево-желтое
        14 to 21,          //оранжево-белое
        16 to 48,          //оранжево-зеленое
        19 to 7,           //бело-синяя
        21 to 14,          //бело-оранжевое
        23 to 30,          //бело-красное
        25 to 46,          //бело-зеленое
        28 to 5,           //красно-синяя
        30 to 23,          //красно-белое
        32 to 39,          //красно-желтое
        34 to 50,          //красно-зеленое
        37 to 1,           //желто-синяя
        39 to 32,          //желто-красное
        41 to 12,          //желто-оранжевое
        43 to 52,          //желто-зеленое
        46 to 25,          //зелено-белое
        48 to 16,          //зелено-оранжевое
        50 to 34,          //зелено-красное
        52 to 43)          //зелено-желтое

//Создаем табличку номеров основных углов to для определенных сочетаний цветов (по цвету его место)
//первое число цвет to например 12 = синий 1 + оранжевый 2
//второе число номер основного(первого) цвета как элемента куба (0..53)
val mainCorner = hashMapOf(
        12 to 0,      //для сине-оранжево-желтого угла
        13 to 6,      //для сине-бело-оранжевого угла
        14 to 8,      //для сине-красно-белого угла
        15 to 2,      //для сине-желто-красного угла
        21 to 11,     //для оранжево-сине-белого угла
        23 to 17,     //для оранжево-бело-зеленого угла
        25 to 9,     //для оранжево-желто-синего угла
        26 to 15,     //для оранжево-зелено-желтого угла
        31 to 20,     //для бело-сине-красного угла
        32 to 18,     //для бело-оранжево-синего угла
        34 to 26,     //для бело-красно-зеленого угла
        36 to 24,     //для бело-зелено-оранжевого угла
        41 to 29,     //для красно-сине-желтого угла
        43 to 27,     //для красно-бело-синего угла
        45 to 35,     //для красно-желто-зеленого угла
        46 to 33,     //для красно-зелено-белого угла
        51 to 38,     //для желто-сине-оранжевого угла
        52 to 44,     //для желто-оранжево-зеленого угла
        54 to 36,     //для желто-красно-синего угла
        56 to 42,     //для желто-зелено-красного угла
        62 to 45,     //для зелено-оранжево-белого угла
        63 to 47,     //для зелено-бело-красного угла
        64 to 53,     //для зелено-красно-желтого угла
        65 to 51)     //для зелено-желто-оранжевого угла

//Создаем табличку соответствия основного и дополнительного угла [где искать второй цвет]
//углы рассматриваем по часовой стрелке to поэтому достаточно первых двух цветов to чтобы пределить угол
//первая и вторая цифра номер соответствующих позиций угла в кубе. т.е. 0->9 to 9->38 to 38->0
val dopCorner = hashMapOf(
        0 to 9,       //сине-оранжево-желтый Л
        2 to 36,       //сине-желто-красный К
        6 to 18,       //сине-бело-оранжевый М
        8 to 27,       //сине-красно-белый И
        9 to 38,      //оранжево-желто-синий Р
        11 to 6,       //оранжево-сине-белый Н
        15 to 51,      //оранжево-зелено-желтый П
        17 to 24,      //оранжево-бело-зеленый О
        18 to 11,      //бело-оранжево-синий А
        20 to 8,      //бело-сине-красный Б
        24 to 45,      //бело-зелено-оранжевый Г
        26 to 33,      //бело-красно-зеленый В
        27 to 20,      //красно-бело-синяя Ф
        29 to 2,      //красно-сине-желтая У
        33 to 47,      //красно-зелено-белая С
        35 to 42,      //красно-желто-зеленая Т
        36 to 29,      //желто-красно-синяя Ц
        38 to 0,      //желто-сине-оранжевая Х
        42 to 53,      //желто-зелено-красная Ч
        44 to 15,      //желто-оранжево-зеленая Ш
        45 to 17,      //зелено-оранжево-белая Д
        47 to 26,      //зелено-бело-красная Е
        51 to 44,      //зелено-желто-оранжевая З
        53 to 35)      //зелено-красно-желтая Ж

// Порядок поиска свободной корзины для переплавки ребра
val edgePriority = hashMapOf(
        0 to 21,     // в первую очередь проверяем не занята ли бело-оранжевое ребро
        1 to 25,            // бело-зеленое
        2 to 48,            // зелено-оранжевое
        3 to 3,             // сине-оранжевое
        4 to 41,            // желто-оранжевое
        5 to 43,            // желто-зеленое
        6 to 37,            // желто-синее
        7 to 39,            // желто-красное
        8 to 7,             // сине-белое
        9 to 34,            // красно-зеленое
        10 to 28)            // красно-синее

// Порядок поиска свободной корзины для переплавки угла
val cornerPriority = hashMapOf(
        0 to 26,     // в первую очередь проверяем не занят ли бело-красно-зеленый угол
        1 to 44,            // желто-зелено-оранжевый
        2 to 36,            // желто-красно-синий
        3 to 42,            // желто-красно-зеленый
        4 to 38,            // желто-сине-оранжевый
        5 to 20,            // бело-сине-красный
        6 to 24)            // бело-зелено-оранжевый

val pllTopLayerColor = hashMapOf(
        0 to "111232343424",    //смежные окошки
        1 to "111242323434",    //противоположные окошки
        2 to "121212343434",    //рельсы
        3 to "131242313424",    //шахматы
        4 to "131223412344",    //запад
        5 to "111233422344",    //юг
        6 to "111243432324",    //светофор
        7 to "341224133412",    //австралия
        8 to "411224132343",    //смежный треугольник
        9 to "311223434142",    //противоположный треугольник
        10 to "214123432341",    //черепаха
        11 to "311224143432",    //угол
        12 to "133422311244",    //правые кирпичи
        13 to "113442331224",    //левые кирпичи
        14 to "411232324143",    //убийца
        15 to "141223432314",    //экватор
        16 to "324141233412",    //встречная машинка
        17 to "243412334121",    //попутная машинка
        18 to "424142331213",    //ближняя улитка
        19 to "242314133421",    //дальняя улитка
        20 to "111223442334")    //север

//координаты круга подсветки слота
//передний правый угол (координаты x - 0.57, y - 0.42, radius - 0.16)
//передний левый угол (0.43, 0.41, 0.16)
//верхний угол (0.5, 0.32, 0.15)
//верхнее правое ребро (0.67, 0.25, 0.13)
//нижнее правое ребро (0.74, 0.34, 0.14)
//верхнее левое ребро (0.3, 0.25, 0.13)
//нижнее левое ребро (0.25, 0.32, 0.14)
val slotLightingCoordinate = hashMapOf(
        0 to Triple(0.57, 0.42, 0.16),
        1 to Triple(0.43, 0.41, 0.16),
        2 to Triple(0.50, 0.32, 0.15),
        3 to Triple(0.67, 0.25, 0.13),
        4 to Triple(0.74, 0.34, 0.14),
        5 to Triple(0.30, 0.25, 0.13),
        6 to Triple(0.25, 0.32, 0.14)
)

//номера элементов кубика для соответствующего слота
//в принципе второй элемент пары это dopCorner[] или dopEdge[] от первого элемента
//но хранить парой понятнее
val slotElementNumbers = hashMapOf(
        0 to Pair(11,6),
        1 to Pair(6,18),
        2 to Pair(18,11),
        3 to Pair(21,14),
        4 to Pair(14,21),
        5 to Pair(19,7),
        6 to Pair(7,19)
)

val ollScramble = hashMapOf(
        0 to "S (R' U') (R U R U R) U' R' S'",                          //Снежинка
        1 to "(F R' F' R) U2 (F R' F' R) (U' R U' R')",                 //Домино
        2 to "(F R' F' R) U2 (F R' F' R) (R U2 R')",                    //Пуля в коридоре
        3 to "F (R U R' U') S (R U R' U') Fw' ",                        //Пуля в стену
        4 to "Fw (R U R' U') Fw' U F (R U R' U') F'",                   //Вектор с точкой
        5 to "Fw (R U R' U') Fw' U' F (R U R' U') F'",                  //Вектор с блоком
        6 to "(R U2') (R2' F R F') U2' M' (U R U' Rw')",                //Микки Маус с бородой
        7 to "Rw U R' U R U2 Rw2 U' R U' R' U2 Rw",                     //Микки Маус с бакенбардами
        8 to "(Rw U R' U') M (U R U' R')",                              //Школа
        9 to "(R U R' U') M' (U R U' Rw')",                             //Летающий змей
        10 to "(Rw' U' R U') (R' U R U') (R' U2 Rw)",                   //Чистый бумеранг 1–3
        11 to "F (R U R' U') (R U R' U') (R U R' U') (R U R' U') F'",   //Чистый бумеранг 2–1
        12 to "F' (L' U' L U) (L' U' L U) (L' U' L U) (L' U' L U) F",   //Чистый бумеранг 1–2
        13 to "(Rw U2) (R' U' R U R' U' R U') Rw'",                     //Чистый бумеранг 3–1
        14 to "(Rw U') (Rw2' U Rw2 U Rw2' U') Rw",                      //Чистый бумеранг 2–3 (Официант)
        15 to "(R' F) (R2 B') (R2' F') (R2 B) R'",                      //Чистый бумеранг 3–2
        16 to "L' U2 L U2 (L F' L' F)",                                 //Правая молния с блоком
        17 to "R U2 R' U2 (R' F R F')",                                 //Левая молния с блоком
        18 to "F (U R U' R') F' U' F (U R U' R') F'",                   //Левая молния с точкой
        19 to "F (U R U' R') F' U' F' (U' L' U L) F",                   //Правая молния с точкой
        20 to "F (R U R' U') F'",                                       //Левый мягкий знак с точкой
        21 to "F' (L' U' L U) F",                                       //Правый мягкий знак с точкой
        22 to "L F' (L' U' L U) F U' L'",                               //Левый мягкий знак с блоком
        23 to "R' F (R U R' U') F' U R",                                //Правый мягкий знак с блоком
        24 to "(R' U' R U' R' U2 R) F (R U R' U') F'",                  //Правый петух с точкой
        25 to "S (R' U') (R U R U R) U' R' S' F (R U R' U') F'",        //Левый петух с точкой
        26 to "F U (R U2 R' U) (R U2 R' U') F'",                        //Правый петух с блоком
        27 to "(R U' R') (F' U F) (R U R') (U R U' R')",                //Левый петух с блоком
        28 to "(Rw U R' U) R U2 Rw'",                                   //Левый квадрат
        29 to "(Lw' U' L U') L' U2 Lw",                                 //Правый квадрат
        30 to "(R U R' U') (R' F R F')",                                //Галстук с блоком
        31 to "(R U2 R') (F R' F') (R2 U2 R')",                         //Галстук с точкой
        32 to "F R' F' R U R U R' U' R U' R'",                          //Метро с точкой
        33 to "R U2 R2 U' F' U F R2 U' R'",                             //Метро с блоком
        34 to "242314133421",    //дальняя
        35 to "242314133421",    //дальняя
        36 to "242314133421",    //дальняя
        37 to "242314133421",    //дальняя
        38 to "242314133421",    //дальняя
        39 to "242314133421",    //дальняя
        40 to "242314133421",    //дальняя
        41 to "242314133421",    //дальняя
        42 to "242314133421",    //дальняя
        43 to "242314133421",    //дальняя
        44 to "242314133421",    //дальняя
        45 to "242314133421",    //дальняя
        46 to "242314133421",    //дальняя
        47 to "242314133421",    //дальняя
        48 to "242314133421",    //дальняя
        49 to "242314133421",    //дальняя
        50 to "242314133421",    //дальняя
        51 to "242314133421",    //дальняя
        52 to "242314133421",    //дальняя
        53 to "242314133421",    //дальняя
        54 to "242314133421",    //дальняя
        55 to "242314133421",    //дальняя
        56 to "111223442334")    //север

val ollPhaseName = hashMapOf(
        0 to Pair(11,6),
        1 to Pair(6,18),
        2 to Pair(18,11),
        3 to Pair(21,14),
        4 to Pair(14,21),
        5 to Pair(19,7),
        6 to Pair(7,19)
)